{"version":3,"sources":["tx-helper.ts","signer.ts","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["signTransactions","a","transactionsAndSigners","wallet","connection","getRecentBlockhash","blockhash","forEach","transaction","signers","recentBlockhash","setSigners","publicKey","map","s","length","partialSign","signAllTransactions","sendSignedTransaction","signedTransaction","timeout","rawTransaction","serialize","startTime","getUnixTs","slot","sendRawTransaction","skipPreflight","txid","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","simulateResult","simulateTransaction","value","logs","i","line","startsWith","slice","JSON","stringify","commitment","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","error","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","Date","getTime","ms","MetadataKey","METADATA_PROGRAM_ID","Creator","address","verified","share","this","Data","name","symbol","uri","sellerFeeBasisPoints","creators","Metadata","key","updateAuthority","mint","data","primarySaleHappened","isMutable","masterEdition","edition","MetadataV1","METADATA_SCHEMA","Map","supply","maxSupply","printingMint","oneTimePrintingAuthorizationMint","MasterEditionV1","kind","fields","type","MasterEditionV2","parent","EditionV1","ledger","EditionMarker","decodeMetadata","buffer","metadata","borsh","getProgramAccounts","programId","configOrCommitment","extra","dataSlice","filters","_buildArgs","unsafeRes","item","account","Buffer","from","executable","lamports","owner","pubkey","signAllMetadataFromCandyMachine","candyMachineAddress","batchSize","handleOut","console","log","getAccountsByCreatorAddress","metadataByCandyMachine","getCandyMachineVerifiedMetadata","toBase58","candyVerifiedListToSign","sendSignMetadata","creatorAddress","memcmp","offset","bytes","metadataAccounts","decodedAccounts","decoded","accountPubkey","store","push","metadataList","candyAddress","verifiedList","meta","verifiedCandy","verifiedCreator","creator","PublicKey","batchsize","total","txList","sliceAmount","removed","splice","delay","signMetadataBatch","tx","signedTxs","Transaction","signMetadataSingle","instructions","keys","isSigner","isWritable","ConnectButton","styled","WalletDialogButton","SignContainer","div","SignButton","Button","options","label","customStyles","option","provided","state","borderBottom","color","isSelected","Home","props","useWallet","anchor","Connection","useState","String","signoutput","setSignOutput","candyid","setCandy","handleChangeOut","newval","onSignAll","className","styles","TextField","onChange","event","target","id","variant","placeholder","connected","onClick","network","process","REACT_APP_SOLANA_NETWORK","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSolletWallet","autoConnect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5403c109.chunk.js","sourcesContent":["import {\r\n    Commitment,\r\n    Connection,\r\n    RpcResponseAndContext,\r\n    SignatureStatus,\r\n    SimulatedTransactionResponse,\r\n    Transaction,\r\n    TransactionSignature,\r\n    Account\r\n  } from '@solana/web3.js';\r\n\r\nexport async function signTransactions({\r\n  transactionsAndSigners,\r\n  wallet,\r\n  connection,\r\n}: {\r\n  transactionsAndSigners: {\r\n    transaction: Transaction;\r\n    signers?: Array<Account>;\r\n  }[];\r\n  wallet: any;\r\n  connection: Connection;\r\n}) {\r\n  const blockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\r\n  transactionsAndSigners.forEach(({ transaction, signers = [] }) => {\r\n    transaction.recentBlockhash = blockhash;\r\n    transaction.setSigners(\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey)\r\n    );\r\n    if (signers?.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n  });\r\n  return await wallet.signAllTransactions(\r\n    transactionsAndSigners.map(({ transaction }) => transaction)\r\n  );\r\n}\r\nconst DEFAULT_TIMEOUT = 15000;\r\n\r\nexport async function sendSignedTransaction({\r\n    signedTransaction,\r\n    connection,\r\n    timeout = DEFAULT_TIMEOUT,\r\n  }: {\r\n    signedTransaction: Transaction;\r\n    connection: Connection;\r\n    sendingMessage?: string;\r\n    sentMessage?: string;\r\n    successMessage?: string;\r\n    timeout?: number;\r\n  }): Promise<{ txid: string; slot: number }> {\r\n    const rawTransaction = signedTransaction.serialize();\r\n    const startTime = getUnixTs();\r\n    let slot = 0;\r\n    const txid: TransactionSignature = await connection.sendRawTransaction(\r\n      rawTransaction,\r\n      {\r\n        skipPreflight: true,\r\n      },\r\n    );\r\n  \r\n    //log.debug('Started awaiting confirmation for', txid);\r\n  \r\n    let done = false;\r\n    (async () => {\r\n      while (!done && getUnixTs() - startTime < timeout) {\r\n        connection.sendRawTransaction(rawTransaction, {\r\n          skipPreflight: true,\r\n        });\r\n        await sleep(500);\r\n      }\r\n    })();\r\n    try {\r\n      const confirmation = await awaitTransactionSignatureConfirmation(\r\n        txid,\r\n        timeout,\r\n        connection,\r\n        'recent',\r\n        true,\r\n      );\r\n  \r\n      if (!confirmation)\r\n        throw new Error('Timed out awaiting confirmation on transaction');\r\n  \r\n      if (confirmation.err) {\r\n        //log.error(confirmation.err);\r\n        throw new Error('Transaction failed: Custom instruction error');\r\n      }\r\n  \r\n      slot = confirmation?.slot || 0;\r\n    } catch (err : any) {\r\n      //log.error('Timeout Error caught', err);\r\n      if (err.timeout) {\r\n        throw new Error('Timed out awaiting confirmation on transaction');\r\n      }\r\n      let simulateResult: SimulatedTransactionResponse | null = null;\r\n      try {\r\n        simulateResult = (\r\n          await simulateTransaction(connection, signedTransaction, 'single')\r\n        ).value;\r\n      } catch (e) {\r\n        //log.error('Simulate Transaction error', e);\r\n      }\r\n      if (simulateResult && simulateResult.err) {\r\n        if (simulateResult.logs) {\r\n          for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n            const line = simulateResult.logs[i];\r\n            if (line.startsWith('Program log: ')) {\r\n              throw new Error(\r\n                'Transaction failed: ' + line.slice('Program log: '.length),\r\n              );\r\n            }\r\n          }\r\n        }\r\n        throw new Error(JSON.stringify(simulateResult.err));\r\n      }\r\n      // throw new Error('Transaction failed');\r\n    } finally {\r\n      done = true;\r\n    }\r\n  \r\n    //log.debug('Latency', txid, getUnixTs() - startTime);\r\n    return { txid, slot };\r\n  }\r\n  \r\n  async function simulateTransaction(\r\n    connection: Connection,\r\n    transaction: Transaction,\r\n    commitment: Commitment,\r\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n    // @ts-ignore\r\n    transaction.recentBlockhash = await connection._recentBlockhash(\r\n      // @ts-ignore\r\n      connection._disableBlockhashCaching,\r\n    );\r\n  \r\n    const signData = transaction.serializeMessage();\r\n    // @ts-ignore\r\n    const wireTransaction = transaction._serialize(signData);\r\n    const encodedTransaction = wireTransaction.toString('base64');\r\n    const config: any = { encoding: 'base64', commitment };\r\n    const args = [encodedTransaction, config];\r\n  \r\n    // @ts-ignore\r\n    const res = await connection._rpcRequest('simulateTransaction', args);\r\n    if (res.error) {\r\n      throw new Error('failed to simulate transaction: ' + res.error.message);\r\n    }\r\n    return res.result;\r\n  }\r\n  \r\n  async function awaitTransactionSignatureConfirmation(\r\n    txid: TransactionSignature,\r\n    timeout: number,\r\n    connection: Connection,\r\n    commitment: Commitment = 'recent',\r\n    queryStatus = false,\r\n  ): Promise<SignatureStatus | null | void> {\r\n    let done = false;\r\n    let status: SignatureStatus | null | void = {\r\n      slot: 0,\r\n      confirmations: 0,\r\n      err: null,\r\n    };\r\n    let subId = 0;\r\n    // eslint-disable-next-line no-async-promise-executor\r\n    status = await new Promise(async (resolve, reject) => {\r\n      setTimeout(() => {\r\n        if (done) {\r\n          return;\r\n        }\r\n        done = true;\r\n        //log.warn('Rejecting for timeout...');\r\n        reject({ timeout: true });\r\n      }, timeout);\r\n      try {\r\n        subId = connection.onSignature(\r\n          txid,\r\n          (result, context) => {\r\n            done = true;\r\n            status = {\r\n              err: result.err,\r\n              slot: context.slot,\r\n              confirmations: 0,\r\n            };\r\n            if (result.err) {\r\n              //log.warn('Rejected via websocket', result.err);\r\n              reject(status);\r\n            } else {\r\n              //log.debug('Resolved via websocket', result);\r\n              resolve(status);\r\n            }\r\n          },\r\n          commitment,\r\n        );\r\n      } catch (e) {\r\n        done = true;\r\n        //log.error('WS error in setup', txid, e);\r\n      }\r\n      while (!done && queryStatus) {\r\n        // eslint-disable-next-line no-loop-func\r\n        (async () => {\r\n          try {\r\n            const signatureStatuses = await connection.getSignatureStatuses([\r\n              txid,\r\n            ]);\r\n            status = signatureStatuses && signatureStatuses.value[0];\r\n            if (!done) {\r\n              if (!status) {\r\n                //log.debug('REST null result for', txid, status);\r\n              } else if (status.err) {\r\n                //log.error('REST error for', txid, status);\r\n                done = true;\r\n                reject(status.err);\r\n              } else if (!status.confirmations) {\r\n                //log.error('REST no confirmations for', txid, status);\r\n              } else {\r\n                //log.debug('REST confirmation for', txid, status);\r\n                done = true;\r\n                resolve(status);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            if (!done) {\r\n              //log.error('REST connection error: txid', txid, e);\r\n            }\r\n          }\r\n        })();\r\n        await sleep(2000);\r\n      }\r\n    });\r\n  \r\n    //@ts-ignore\r\n    if (connection._signatureSubscriptions[subId])\r\n      connection.removeSignatureListener(subId);\r\n    done = true;\r\n    //log.debug('Returning status', status);\r\n    return status;\r\n  }\r\n\r\nconst getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n","import { Keypair, PublicKey, Connection, AccountInfo, Transaction } from '@solana/web3.js';\r\nimport BN from \"bn.js\";\r\nimport * as borsh from \"borsh\"\r\nimport { signTransactions, sendSignedTransaction } from './tx-helper';\r\n/*\r\n Get accounts by candy machine creator address\r\n Get only verified ones\r\n Get only unverified ones with creator address\r\n Grab n at a time and batch sign and send transaction\r\n\r\n PS: Don't sign candy machine addresses that you do not know about. Signing verifies your participation.\r\n*/\r\nconst MAX_NAME_LENGTH = 32;\r\nconst MAX_URI_LENGTH = 200;\r\nconst MAX_SYMBOL_LENGTH = 10;\r\nconst MAX_CREATOR_LEN = 32 + 1 + 1;\r\nconst METADATA_PROGRAM_ID = \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\r\ntype AccountAndPubkey = {\r\n  pubkey: string;\r\n  account: AccountInfo<Buffer>;\r\n};\r\n\r\nenum MetadataKey {\r\n  Uninitialized = 0,\r\n  MetadataV1 = 4,\r\n  EditionV1 = 1,\r\n  MasterEditionV1 = 2,\r\n  MasterEditionV2 = 6,\r\n  EditionMarker = 7\r\n}\r\n\r\nclass MasterEditionV1 {\r\n  key: MetadataKey;\r\n  supply: BN;\r\n  maxSupply?: BN;\r\n  printingMint: PublicKey;\r\n  oneTimePrintingAuthorizationMint: PublicKey;\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    supply: BN;\r\n    maxSupply?: BN;\r\n    printingMint: PublicKey;\r\n    oneTimePrintingAuthorizationMint: PublicKey;\r\n  }) {\r\n    this.key = MetadataKey.MasterEditionV1;\r\n    this.supply = args.supply;\r\n    this.maxSupply = args.maxSupply;\r\n    this.printingMint = args.printingMint;\r\n    this.oneTimePrintingAuthorizationMint =\r\n      args.oneTimePrintingAuthorizationMint;\r\n  };\r\n}\r\n\r\nclass MasterEditionV2 {\r\n  key: MetadataKey;\r\n  supply: BN;\r\n  maxSupply?: BN;\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    supply: BN;\r\n    maxSupply?: BN;\r\n  }) {\r\n    this.key = MetadataKey.MasterEditionV2;\r\n    this.supply = args.supply;\r\n    this.maxSupply = args.maxSupply;\r\n  };\r\n}\r\n\r\nclass EditionMarker {\r\n  key: MetadataKey;\r\n  ledger: number[];\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    ledger: number[];\r\n  }) {\r\n    this.key = MetadataKey.EditionMarker;\r\n    this.ledger = args.ledger;\r\n  };\r\n}\r\n\r\nclass Edition {\r\n  key: MetadataKey;\r\n  parent: PublicKey;\r\n  edition: BN;\r\n  constructor(args: {\r\n    key: MetadataKey;\r\n    parent: PublicKey;\r\n    edition: BN;\r\n  }) {\r\n    this.key = MetadataKey.EditionV1;\r\n    this.parent = args.parent;\r\n    this.edition = args.edition;\r\n  };\r\n}\r\n\r\nclass Creator {\r\n  address: string;\r\n  verified: boolean;\r\n  share: number;\r\n\r\n  constructor(args: {\r\n    address: string;\r\n    verified: boolean;\r\n    share: number;\r\n  }) {\r\n    this.address = args.address;\r\n    this.verified = args.verified;\r\n    this.share = args.share;\r\n  }\r\n}\r\n\r\nclass Data {\r\n  name: string;\r\n  symbol: string;\r\n  uri: string;\r\n  sellerFeeBasisPoints: number;\r\n  creators: Creator[] | null;\r\n  constructor(args: {\r\n    name: string;\r\n    symbol: string;\r\n    uri: string;\r\n    sellerFeeBasisPoints: number;\r\n    creators: Creator[] | null;\r\n  }) {\r\n    this.name = args.name;\r\n    this.symbol = args.symbol;\r\n    this.uri = args.uri;\r\n    this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\r\n    this.creators = args.creators;\r\n  };\r\n}\r\n\r\nclass Metadata {\r\n  key: MetadataKey;\r\n  updateAuthority: PublicKey;\r\n  mint: PublicKey;\r\n  data: Data;\r\n  primarySaleHappened: boolean;\r\n  isMutable: boolean;\r\n  masterEdition?: PublicKey;\r\n  edition?: PublicKey;\r\n  constructor(args: {\r\n    updateAuthority: PublicKey;\r\n    mint: PublicKey;\r\n    data: Data;\r\n    primarySaleHappened: boolean;\r\n    isMutable: boolean;\r\n    masterEdition?: PublicKey;\r\n  }) {\r\n    this.key = MetadataKey.MetadataV1;\r\n    this.updateAuthority = args.updateAuthority;\r\n    this.mint = args.mint;\r\n    this.data = args.data;\r\n    this.primarySaleHappened = args.primarySaleHappened;\r\n    this.isMutable = args.isMutable;\r\n  };\r\n}\r\n\r\nconst METADATA_SCHEMA = new Map<any, any>([\r\n  [\r\n    MasterEditionV1,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['supply', 'u64'],\r\n        ['maxSupply', { kind: 'option', type: 'u64' }],\r\n        ['printingMint', 'pubkey'],\r\n        ['oneTimePrintingAuthorizationMint', [32]],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    MasterEditionV2,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['supply', 'u64'],\r\n        ['maxSupply', { kind: 'option', type: 'u64' }],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Edition,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['parent', [32]],\r\n        ['edition', 'u64'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Data,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['name', 'string'],\r\n        ['symbol', 'string'],\r\n        ['uri', 'string'],\r\n        ['sellerFeeBasisPoints', 'u16'],\r\n        ['creators', { kind: 'option', type: [Creator] }],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Creator,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['address', [32]],\r\n        ['verified', 'u8'],\r\n        ['share', 'u8'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    Metadata,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['updateAuthority', [32]],\r\n        ['mint', [32]],\r\n        ['data', Data],\r\n        ['primarySaleHappened', 'u8'],\r\n        ['isMutable', 'u8'],\r\n      ],\r\n    },\r\n  ],\r\n  [\r\n    EditionMarker,\r\n    {\r\n      kind: 'struct',\r\n      fields: [\r\n        ['key', 'u8'],\r\n        ['ledger', [31]],\r\n      ],\r\n    },\r\n  ],\r\n]);\r\n\r\nasync function decodeMetadata(buffer) {\r\n  const metadata = borsh.deserializeUnchecked(METADATA_SCHEMA, Metadata, buffer);\r\n  return metadata;\r\n};\r\n\r\nasync function getProgramAccounts(\r\n  connection: Connection,\r\n  programId: String,\r\n  configOrCommitment?: any,\r\n): Promise<Array<AccountAndPubkey>> {\r\n  const extra: any = {};\r\n  let commitment;\r\n  //let encoding;\r\n\r\n  if (configOrCommitment) {\r\n    if (typeof configOrCommitment === 'string') {\r\n      commitment = configOrCommitment;\r\n    } else {\r\n      commitment = configOrCommitment.commitment;\r\n      //encoding = configOrCommitment.encoding;\r\n\r\n      if (configOrCommitment.dataSlice) {\r\n        extra.dataSlice = configOrCommitment.dataSlice;\r\n      }\r\n\r\n      if (configOrCommitment.filters) {\r\n        extra.filters = configOrCommitment.filters;\r\n      }\r\n    }\r\n  }\r\n\r\n  const args = connection._buildArgs([programId], commitment, 'base64', extra);\r\n  const unsafeRes = await (connection as any)._rpcRequest(\r\n    'getProgramAccounts',\r\n    args,\r\n  );\r\n  //console.log(unsafeRes)\r\n  const data = (\r\n    unsafeRes.result as Array<{\r\n      account: AccountInfo<[string, string]>;\r\n      pubkey: string;\r\n    }>\r\n  ).map(item => {\r\n    return {\r\n      account: {\r\n        // TODO: possible delay parsing could be added here\r\n        data: Buffer.from(item.account.data[0], 'base64'),\r\n        executable: item.account.executable,\r\n        lamports: item.account.lamports,\r\n        // TODO: maybe we can do it in lazy way? or just use string\r\n        owner: item.account.owner,\r\n      } as AccountInfo<Buffer>,\r\n      pubkey: item.pubkey,\r\n    };\r\n  });\r\n\r\n  return data;\r\n}\r\n\r\nexport async function signAllMetadataFromCandyMachine(\r\n  connection, \r\n  wallet, \r\n  candyMachineAddress, \r\n  batchSize,\r\n  handleOut\r\n  ){\r\n  console.log(wallet)\r\n  let metadataByCandyMachine = await getAccountsByCreatorAddress(candyMachineAddress, connection)\r\n  console.log(`Found ${metadataByCandyMachine.length} nft's minted by candy machine ${candyMachineAddress}`)\r\n  handleOut(`Found ${metadataByCandyMachine.length} nft's minted by candy machine ${candyMachineAddress}` )\r\n  let candyVerifiedListToSign = await getCandyMachineVerifiedMetadata(metadataByCandyMachine, candyMachineAddress, wallet.publicKey.toBase58())\r\n  console.log(`Found ${candyVerifiedListToSign.length} nft's to sign by  ${wallet.publicKey.toBase58()}`)\r\n  handleOut(`Found ${candyVerifiedListToSign.length} nft's to sign by  ${wallet.publicKey.toBase58()}`)\r\n  if (candyVerifiedListToSign.length == 0) { return }\r\n  await sendSignMetadata(connection, wallet, candyVerifiedListToSign, batchSize, handleOut)\r\n}\r\n\r\nasync function getAccountsByCreatorAddress(creatorAddress, connection) {\r\n  console.log(creatorAddress)\r\n  let metadataAccounts = await getProgramAccounts(connection, METADATA_PROGRAM_ID, {\r\n    filters: [\r\n      {\r\n        memcmp: {\r\n          offset:\r\n            1 + // key\r\n            32 + // update auth\r\n            32 + // mint\r\n            4 + // name string length\r\n            MAX_NAME_LENGTH + // name\r\n            4 + // uri string length\r\n            MAX_URI_LENGTH + // uri*\r\n            4 + // symbol string length\r\n            MAX_SYMBOL_LENGTH + // symbol\r\n            2 + // seller fee basis points\r\n            1 + // whether or not there is a creators vec\r\n            4 + // creators vec length\r\n            0 * MAX_CREATOR_LEN,\r\n          bytes: creatorAddress,\r\n        },\r\n      },\r\n    ],\r\n  })\r\n  let decodedAccounts : any[] = []\r\n  for (let i = 0; i < metadataAccounts.length; i++) {\r\n    let e = metadataAccounts[i];\r\n    let decoded = await decodeMetadata(e.account.data)\r\n    let accountPubkey = e.pubkey\r\n    let store = [decoded, accountPubkey]\r\n    decodedAccounts.push(store)\r\n  }\r\n  return decodedAccounts\r\n}\r\n\r\nasync function getCandyMachineVerifiedMetadata(metadataList, candyAddress, creatorAddress){\r\n  let verifiedList : any[] = [];\r\n  metadataList.forEach(meta => {\r\n    let verifiedCandy = false;\r\n    let verifiedCreator = true;\r\n    meta[0].data.creators.forEach(creator => {\r\n      if (new PublicKey(creator.address).toBase58() == candyAddress && creator.verified === 1) {\r\n        verifiedCandy = true;\r\n      }\r\n      if (new PublicKey(creator.address).toBase58() == creatorAddress && creator.verified === 0) {\r\n        verifiedCreator = false;\r\n      }\r\n    });\r\n    if(verifiedCandy && !verifiedCreator){\r\n      verifiedList.push(meta)\r\n    }\r\n  });\r\n  return verifiedList\r\n}\r\n\r\nasync function sendSignMetadata(\r\n  connection,\r\n  wallet,\r\n  metadataList,\r\n  batchsize,\r\n  handleOut\r\n) {\r\n  let total = 0;\r\n  let txList : any[] = []\r\n  while(metadataList.length > 0){\r\n    console.log(\"Signing metadata\")\r\n    handleOut(\"Signing metadata..\")\r\n    let sliceAmount = batchsize;\r\n    if (metadataList.length < batchsize) {\r\n      sliceAmount = metadataList.length;\r\n    }\r\n    var removed = metadataList.splice(0,sliceAmount);\r\n    total += sliceAmount;\r\n    await delay(500)\r\n    let tx = await signMetadataBatch(removed, connection, wallet)\r\n    txList.push(tx)\r\n    console.log(`Processed ${total} nfts`)\r\n  }\r\n  console.log(\"Signing all txs..\")\r\n  let signedTxs = await signTransactions({\r\n    transactionsAndSigners: txList,\r\n    wallet: wallet,\r\n    connection: connection\r\n  })\r\n  for (let i = 0; i < signedTxs.length; i++) {\r\n    const signedTransaction : Transaction = signedTxs[i];\r\n    await sendSignedTransaction({\r\n      signedTransaction,\r\n      connection,\r\n    });\r\n  }\r\n  console.log(\"Finished signing metadata..\")\r\n  handleOut(\"Finished signing metadata..\")\r\n}\r\n\r\nasync function signMetadataBatch(metadataList, connection, wallet){\r\n  \r\n  const signers: Keypair[] = [];\r\n  let transaction = new Transaction();\r\n  \r\n  for (let i = 0; i < metadataList.length; i++) {\r\n    const meta = metadataList[i];\r\n    await signMetadataSingle(meta[1], wallet.publicKey.toBase58(), transaction.instructions)\r\n  };\r\n  return {transaction: transaction, signers: signers};\r\n  //await sendTransactionWithRetryWithKeypair(connection, keypair, instructions, [], 'single')\r\n}\r\n\r\n\r\n\r\nasync function signMetadataSingle(\r\n  metadata,\r\n  creator,\r\n  instructions,\r\n) {\r\n  const metadataProgramId = new PublicKey(METADATA_PROGRAM_ID)\r\n  const data = Buffer.from([7]);\r\n  const keys = [\r\n    {\r\n      pubkey: new PublicKey(metadata),\r\n      isSigner: false,\r\n      isWritable: true,\r\n    },\r\n    {\r\n      pubkey: new PublicKey(creator),\r\n      isSigner: true,\r\n      isWritable: false,\r\n    },\r\n  ];\r\n  instructions.push(\r\n    ({\r\n      keys,\r\n      programId: METADATA_PROGRAM_ID,\r\n      data,\r\n    }),\r\n  );\r\n}\r\n\r\nfunction delay(ms: number) {\r\n  return new Promise( resolve => setTimeout(resolve, ms) );\r\n}\r\n","import { useState} from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { Button, TextField } from \"@material-ui/core\";\r\nimport * as anchor from \"@project-serum/anchor\";\r\nimport { useWallet } from \"@solana/wallet-adapter-react\";\r\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\r\nimport { signAllMetadataFromCandyMachine } from \"./signer\";\r\nimport Select from 'react-select'\r\n\r\nconst ConnectButton = styled(WalletDialogButton)``;\r\nconst SignContainer = styled.div``; // add your styles here\r\nconst SignButton = styled(Button)``; // add your styles here\r\nconst options = [\r\n  { value: 'https://api.devnet.solana.com', label: 'devnet' },\r\n  { value: 'https://api.mainnet-beta.solana.com', label: 'mainnet' },\r\n]\r\nconst customStyles = {\r\n  option: (provided, state) => ({\r\n    ...provided,\r\n    borderBottom: '1px dotted pink',\r\n    color: state.isSelected ? 'red' : 'blue',\r\n  })\r\n}\r\nexport interface HomeProps {}\r\n\r\nconst Home = (props: HomeProps) => {\r\n  const wallet = useWallet();\r\n  let connection = new anchor.web3.Connection(\"https://api.devnet.solana.com\");\r\n  const [signoutput, setSignOutput] = useState(String);\r\n  const [candyid, setCandy] = useState(String);\r\n  const setCandyChange = (event) => {\r\n    setCandy(event.target.value);\r\n  };\r\n  const handleChangeOut = (newval) => {\r\n    setSignOutput(newval);\r\n  };\r\n  const onSignAll = async () => {\r\n    handleChangeOut(\"signing..\");\r\n    try {\r\n      if (candyid == \"\") {\r\n        handleChangeOut(\"please enter candy address..\");\r\n        return\r\n      }\r\n      await signAllMetadataFromCandyMachine(\r\n        connection,\r\n        wallet,\r\n        candyid,\r\n        10,\r\n        handleChangeOut\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n      handleChangeOut(\"could not sign..\");\r\n    }\r\n  };\r\n  const disconnectWallet = async () => {\r\n    wallet?.disconnect();\r\n  };\r\n  return (\r\n    <main className=\"mainc\">\r\n      <h4>Candy Machine Metadata Signer</h4>\r\n      <div className=\"selectorC\">\r\n      \r\n      <Select styles={customStyles} options={options} />\r\n      </div>\r\n      <div className=\"cndymch\">\r\n        <TextField\r\n          onChange={setCandyChange}\r\n          className=\"textfield\"\r\n          id=\"outlined-basic\"\r\n          label=\"Candy machine id\"\r\n          variant=\"outlined\"\r\n          placeholder=\"Candy machine id\"\r\n        />\r\n      </div>\r\n      <div className=\"signBtn\">\r\n        <SignContainer>\r\n          {!wallet.connected ? (\r\n            <ConnectButton>Connect Wallet</ConnectButton>\r\n          ) : (\r\n            <SignButton onClick={onSignAll} variant=\"contained\">\r\n              {\" \"}\r\n              SIGN\r\n            </SignButton>\r\n          )}\r\n        </SignContainer>\r\n      </div>\r\n      <div className=\"light\">{signoutput}</div>\r\n    </main>\r\n  );\r\n};\r\nexport default Home;\r\n","import \"./App.css\";\r\nimport { useMemo } from \"react\";\r\nimport Home from \"./Home\";\r\nimport { clusterApiUrl } from \"@solana/web3.js\";\r\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\r\nimport {\r\n  getPhantomWallet,\r\n  getSolflareWallet,\r\n  getSolletWallet,\r\n} from \"@solana/wallet-adapter-wallets\";\r\nimport {\r\n  ConnectionProvider,\r\n  WalletProvider,\r\n} from \"@solana/wallet-adapter-react\";\r\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\r\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\r\nconst App = () => {\r\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\r\n  const wallets = useMemo(\r\n    () => [getPhantomWallet(), getSolflareWallet(), getSolletWallet()],\r\n    []\r\n  );\r\n  return (\r\n    <ConnectionProvider endpoint={endpoint}>\r\n      <WalletProvider wallets={wallets} autoConnect>\r\n        <WalletDialogProvider>\r\n          <Home\r\n          />\r\n        </WalletDialogProvider>\r\n      </WalletProvider>\r\n    </ConnectionProvider>\r\n  );\r\n};\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}